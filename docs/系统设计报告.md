# FReg 系统设计报告

**项目名称**：AR 智慧课堂伴侣 (FReg)

**文档版本**：v1.0

**更新日期**：2026年1月18日

---

## 目录

1. [系统概述](#1-系统概述)
2. [系统架构](#2-系统架构)
3. [数据结构设计](#3-数据结构设计)
4. [机器学习模块](#4-机器学习模块)
5. [Rokid SDK 使用](#5-rokid-sdk-使用)
6. [手机与眼镜通信协议](#6-手机与眼镜通信协议)
7. [开源库依赖](#7-开源库依赖)
8. [关键技术实现](#8-关键技术实现)

---

## 1. 系统概述

### 1.1 项目背景

FReg 是一款基于 Rokid AR 眼镜的智慧课堂人脸识别系统，旨在通过 AR 技术辅助教师进行学生考勤和课堂互动管理。系统由两个 Android 应用组成：

| 组件 | 运行平台 | 核心职责 |
|------|----------|----------|
| **m-app** | 手机 (Android 8.0+) | 人脸检测与识别、学生管理、设备连接 |
| **s-app** | Rokid AR 眼镜 (Android 12+) | 图像采集、AR HUD 显示、手势交互 |

### 1.2 系统工作流程

```
1. 眼镜端 (s-app) 通过 CameraX 采集图像
      ↓
2. 图像经 Base64 编码后通过 Rokid SDK 发送至手机端
      ↓
3. 手机端 (m-app) 执行人脸检测 (SCRFD) 和识别 (MobileFaceNet)
      ↓
4. 识别结果通过 Rokid SDK 返回眼镜端
      ↓
5. 眼镜端在 AR HUD 界面显示识别结果
```

### 1.3 核心技术栈

- **编程语言**：Kotlin 2.0.21
- **UI 框架**：Jetpack Compose + Material 3
- **相机框架**：CameraX 1.3.1
- **神经网络推理**：NCNN (Vulkan 加速)
- **设备通信**：Rokid CxrApi SDK
- **数据持久化**：DataStore + kotlinx.serialization

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              m-app (手机端)                              │
│                                                                         │
│  ┌─────────────┐    ┌─────────────────────┐    ┌────────────────────┐  │
│  │   UI Layer  │    │    ML Pipeline      │    │  Communication     │  │
│  │  (Compose)  │    │                     │    │                    │  │
│  │             │    │  ┌───────────────┐  │    │  ┌──────────────┐  │  │
│  │ - Classroom │    │  │ FaceDetector  │  │    │  │ RokidManager │  │  │
│  │ - Students  │◄──►│  │   (SCRFD)     │  │◄──►│  │   (BLE)      │  │  │
│  │ - Device    │    │  └───────┬───────┘  │    │  └──────┬───────┘  │  │
│  │ - Profile   │    │          ↓          │    │         │          │  │
│  └─────────────┘    │  ┌───────────────┐  │    │  ┌──────▼───────┐  │  │
│         ↑           │  │ FaceAlignment │  │    │  │RokidService  │  │  │
│         │           │  └───────┬───────┘  │    │  │ (Foreground) │  │  │
│  ┌──────▼──────┐    │          ↓          │    │  └──────┬───────┘  │  │
│  │    Data     │    │  ┌───────────────┐  │    │         │          │  │
│  │   Layer     │    │  │FaceRecognizer │  │    │  ┌──────▼───────┐  │  │
│  │             │    │  │(MobileFaceNet)│  │    │  │MessageHandler│  │  │
│  │ - Student   │    │  └───────────────┘  │    │  │  (Protocol)  │  │  │
│  │   Repository│    └─────────────────────┘    │  └──────────────┘  │  │
│  │ - DataStore │                               └────────────────────┘  │
│  └─────────────┘                                         │             │
└──────────────────────────────────────────────────────────┼─────────────┘
                                                           │
                                          Rokid SDK (Caps 序列化)
                                                           │
┌──────────────────────────────────────────────────────────┼─────────────┐
│                              s-app (眼镜端)               │             │
│                                                           ↓             │
│  ┌─────────────┐    ┌─────────────────────┐    ┌────────────────────┐  │
│  │   UI Layer  │    │   Camera Module     │    │  Communication     │  │
│  │  (Compose)  │    │                     │    │                    │  │
│  │             │    │  ┌───────────────┐  │    │  ┌──────────────┐  │  │
│  │ - HudScreen │    │  │ GlassesCamera │  │    │  │GlassesBridge │  │  │
│  │ - Pairing   │◄──►│  │   (CameraX)   │  │◄──►│  │(CXRService)  │  │  │
│  │   Screen    │    │  └───────────────┘  │    │  └──────────────┘  │  │
│  └─────────────┘    └─────────────────────┘    └────────────────────┘  │
│         ↑                                                              │
│  ┌──────▼──────┐    ┌─────────────────────┐                           │
│  │ HudViewModel│    │   Input Module      │                           │
│  │             │◄──►│                     │                           │
│  │ - UI State  │    │  - KeyReceiver     │                           │
│  │ - Camera    │    │  - SwipeDetector   │                           │
│  │ - Comm      │    └─────────────────────┘                           │
│  └─────────────┘                                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 模块职责

#### 2.2.1 m-app 模块

| 模块 | 路径 | 职责 |
|------|------|------|
| `ml/` | `com.sustech.bojayL.ml` | 人脸检测、对齐、识别 |
| `rokid/` | `com.sustech.bojayL.rokid` | Rokid SDK 封装、通信管理 |
| `data/` | `com.sustech.bojayL.data` | 数据模型、持久化存储 |
| `ui/` | `com.sustech.bojayL.ui` | Compose UI 组件和页面 |

#### 2.2.2 s-app 模块

| 模块 | 路径 | 职责 |
|------|------|------|
| `camera/` | `...glasses.camera` | CameraX 图像采集 |
| `communication/` | `...glasses.communication` | 通信桥接和协议 |
| `input/` | `...glasses.input` | 触控板手势处理 |
| `ui/` | `...glasses.ui` | HUD 界面组件 |
| `viewmodel/` | `...glasses.viewmodel` | 状态管理 |

---

## 3. 数据结构设计

### 3.1 学生数据模型 (Student)

```kotlin
@Serializable
data class Student(
    val id: String,                    // 唯一标识符 (UUID)
    val studentId: String,             // 学号
    val name: String,                  // 姓名
    val className: String,             // 班级名称
    val grade: String,                 // 年级
    val avatarUrl: String? = null,     // 头像 URL
    val photoUrl: String? = null,      // 证件照 URL
    val parentContact: String? = null, // 家长联系方式
    val faceFeatureId: String? = null, // 人脸特征 ID
    val faceFeature: List<Float>? = null, // 512维人脸特征向量
    val isEnrolled: Boolean = false,   // 是否已录入人脸
    val tags: List<String> = emptyList(), // 标签
    val academicInfo: AcademicInfo? = null,
    val behaviorRecord: BehaviorRecord? = null
)
```

**人脸特征向量**：
- 维度：512 维浮点数
- 来源：MobileFaceNet 模型
- 存储：序列化为 `List<Float>` 持久化到 DataStore
- 用途：与检测到的人脸进行余弦相似度匹配

### 3.2 识别结果 (RecognitionResult)

```kotlin
// 手机端识别结果
data class RecognitionResult(
    val id: String,                          // 记录唯一标识
    val studentId: String?,                  // 学生 ID
    val student: Student? = null,            // 关联学生信息
    val sessionId: String,                   // 所属会话 ID
    val status: RecognitionStatus,           // 识别状态
    val confidence: Float = 0f,              // 置信度 0-1
    val timestamp: Long,                     // 时间戳
    val faceImageUrl: String? = null,        // 抓拍图 URL
    val attendanceStatus: AttendanceStatus = AttendanceStatus.UNKNOWN
)

enum class RecognitionStatus {
    SUCCESS,       // 识别成功
    FAILED,        // 识别失败
    UNKNOWN,       // 未知人员
    PROCESSING     // 识别中
}
```

### 3.3 眼镜端识别结果

```kotlin
// 眼镜端接收的识别结果
data class RecognitionResult(
    val studentId: String?,
    val studentName: String?,
    val className: String?,
    val confidence: Float,
    val tags: List<String>,
    val isKnown: Boolean,
    val timestamp: Long = System.currentTimeMillis()
)
```

### 3.4 设备状态 (DeviceState)

```kotlin
data class DeviceState(
    val connectionType: ConnectionType = ConnectionType.DISCONNECTED,
    val batteryLevel: Int = 0,              // 电量 0-100
    val isCharging: Boolean = false,
    val deviceName: String? = null,
    val deviceId: String? = null,
    val firmwareVersion: String? = null,
    val lastConnectedTime: Long? = null,
    val signalStrength: Int = 0,
    val sdkParams: SdkParams = SdkParams()
)

enum class ConnectionType {
    DISCONNECTED,  // 未连接
    USB,           // USB 连接
    BLUETOOTH,     // 蓝牙连接
    WIFI           // WiFi 连接
}
```

### 3.5 SDK 参数配置

```kotlin
data class SdkParams(
    val recognitionThreshold: RecognitionThreshold = RecognitionThreshold.MEDIUM,
    val captureInterval: CaptureInterval = CaptureInterval.CONTINUOUS,
    val displayBrightness: Int = 80,
    val showReticle: Boolean = true
)

enum class RecognitionThreshold(val value: Float, val label: String) {
    LOW(0.8f, "低"),
    MEDIUM(0.9f, "中"),
    HIGH(0.95f, "高")
}
```

### 3.6 课堂会话 (ClassSession)

```kotlin
data class ClassSession(
    val sessionId: String,                // 会话唯一标识
    val className: String,                // 班级名称
    val courseName: String,               // 课程名称
    val teacherId: String,                // 教师 ID
    val status: SessionStatus = SessionStatus.IDLE,
    val startTime: Long? = null,
    val endTime: Long? = null,
    val totalStudents: Int = 0,
    val recognizedCount: Int = 0,
    val attendanceStats: AttendanceStats = AttendanceStats()
)

enum class SessionStatus {
    IDLE,       // 未开始
    ACTIVE,     // 进行中
    PAUSED,     // 暂停
    ENDED       // 已结束
}
```

### 3.7 数据持久化

使用 **DataStore + kotlinx.serialization** 实现持久化：

```kotlin
class StudentRepository(private val context: Context) {
    
    companion object {
        private val Context.dataStore: DataStore<Preferences> 
            by preferencesDataStore(name = "students")
        private val STUDENTS_KEY = stringPreferencesKey("students_list")
    }
    
    private val json = Json { 
        ignoreUnknownKeys = true
        encodeDefaults = true
    }
    
    // 学生列表 Flow（响应式）
    val studentsFlow: Flow<List<Student>> = context.dataStore.data.map { prefs ->
        val studentsJson = prefs[STUDENTS_KEY]
        if (studentsJson != null) {
            json.decodeFromString<List<Student>>(studentsJson)
        } else {
            defaultStudents
        }
    }
    
    // 保存学生列表
    suspend fun saveStudents(students: List<Student>) {
        context.dataStore.edit { prefs ->
            prefs[STUDENTS_KEY] = json.encodeToString(students)
        }
    }
}
```

---

## 4. 机器学习模块

### 4.1 ML Pipeline 架构

```
                          输入图像 (Bitmap)
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                    CompositeFaceDetector                        │
│                                                                 │
│   ┌─────────────────────────┐  ┌─────────────────────────────┐ │
│   │ InsightfaceNcnnDetector │  │    FaceDetectorMlKit        │ │
│   │     (主检测器)           │  │      (备用检测器)            │ │
│   │                         │  │                             │ │
│   │  - SCRFD 模型           │  │  - Google MLKit             │ │
│   │  - NCNN 推理引擎        │  │  - 云端/本地混合            │ │
│   │  - Vulkan GPU 加速      │  │                             │ │
│   └─────────────────────────┘  └─────────────────────────────┘ │
│                                                                 │
│   检测策略：                                                     │
│   - SCRFD_ONLY: 仅使用 SCRFD                                    │
│   - MLKIT_ONLY: 仅使用 MLKit                                    │
│   - SCRFD_FALLBACK: SCRFD 优先，失败回退 MLKit (默认)            │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                    人脸检测结果 (List<FaceResult>)
                    - 边界框 (RectF)
                    - 置信度 (Float)
                    - 5点关键点 (FloatArray[10])
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                        FaceAlignment                            │
│                                                                 │
│   输入：原始图像 + 5点关键点                                      │
│   输出：112×112 对齐人脸图像                                      │
│                                                                 │
│   算法：相似变换（最小二乘法）                                     │
│   - 计算从源关键点到 InsightFace 标准模板的变换矩阵               │
│   - 标准模板坐标（112×112）：                                     │
│     左眼: (38.29, 51.70)                                        │
│     右眼: (73.53, 51.50)                                        │
│     鼻尖: (56.03, 71.74)                                        │
│     左嘴角: (41.55, 92.37)                                      │
│     右嘴角: (70.73, 92.20)                                      │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                      112×112 对齐人脸
                                ↓
┌─────────────────────────────────────────────────────────────────┐
│                       FaceRecognizer                            │
│                                                                 │
│   模型：MobileFaceNet                                            │
│   推理：NCNN (Vulkan 可选)                                       │
│   输出：512 维特征向量 (FloatArray)                               │
│                                                                 │
│   特征匹配：                                                     │
│   - 余弦相似度计算                                               │
│   - 默认阈值：0.7                                                │
│   - 遍历所有已录入学生，找最高相似度匹配                          │
└─────────────────────────────────────────────────────────────────┘
                                ↓
                      识别结果 (MatchResult)
```

### 4.2 SCRFD 人脸检测器

**模型信息**：
- 模型名称：SCRFD 2.5g_kps
- 模型来源：InsightFace
- 特点：包含 5 点关键点检测
- 模型文件：`scrfd_2.5g_kps-opt2.param/bin`

**JNI 接口**：

```kotlin
object InsightfaceNcnnDetector {
    // 检测结果
    data class FaceResult(
        val rect: RectF,           // 人脸边界框
        val confidence: Float,     // 置信度 (0.0-1.0)
        val landmarks: FloatArray? // 5个关键点 [x1,y1,...,x5,y5]
    )
    
    // 初始化
    suspend fun init(
        context: Context,
        modelType: String = "2.5g_kps",
        useGpu: Boolean = false
    ): Boolean
    
    // 检测
    suspend fun detectFromBitmap(
        bitmap: Bitmap,
        probThreshold: Float = 0.5f,
        nmsThreshold: Float = 0.45f
    ): List<FaceResult>?
    
    // Native 方法
    private external fun nativeInit(assetManager: AssetManager, modelType: String, useGpu: Boolean): Boolean
    private external fun nativeDetect(bitmap: Bitmap, probThreshold: Float, nmsThreshold: Float): FloatArray?
    private external fun nativeRelease()
}
```

**检测结果格式**：
```
FloatArray: [numFaces, x, y, w, h, prob, lm1_x, lm1_y, ..., lm5_y, ...]
每个人脸 15 个值：5 (bbox+prob) + 10 (5 landmarks × 2)
```

### 4.3 MobileFaceNet 人脸识别器

**模型信息**：
- 模型名称：MobileFaceNet
- 输入尺寸：112×112 RGB
- 输出维度：512 维特征向量
- 模型文件：`mobilefacenet-opt.param/bin`

**JNI 接口**：

```kotlin
object FaceRecognizer {
    // 初始化
    suspend fun init(context: Context, modelType: String = "mobilefacenet", useGpu: Boolean = false): Boolean
    
    // 特征提取
    suspend fun extractFeature(faceBitmap: Bitmap): FloatArray?  // 512 维
    
    // 余弦相似度
    fun cosineSimilarity(feature1: FloatArray, feature2: FloatArray): Float
    
    // 学生匹配
    suspend fun matchStudent(
        faceFeature: FloatArray,
        students: List<Student>,
        threshold: Float = 0.7f
    ): MatchResult?
    
    data class MatchResult(
        val student: Student,
        val similarity: Float
    )
}
```

### 4.4 人脸对齐算法

**原理**：基于 5 点关键点的相似变换

```kotlin
object FaceAlignment {
    // InsightFace 标准模板 (112×112)
    private val STANDARD_LANDMARKS = floatArrayOf(
        38.2946f, 51.6963f,  // 左眼
        73.5318f, 51.5014f,  // 右眼
        56.0252f, 71.7366f,  // 鼻尖
        41.5493f, 92.3655f,  // 左嘴角
        70.7299f, 92.2041f   // 右嘴角
    )
    
    // 相似变换：src → dst
    // 变换矩阵形式：[a, -b, tx; b, a, ty]
    // scale = sqrt(a² + b²), angle = atan2(b, a)
    
    fun alignFace(bitmap: Bitmap, landmarks: FloatArray): Bitmap?
}
```

### 4.5 识别处理流程

```kotlin
class RecognitionProcessor(private val context: Context) {
    
    suspend fun process(bitmap: Bitmap): ProcessResult {
        // 1. 人脸检测
        val faces = faceDetector.detectFromBitmap(bitmap)
        if (faces.isNullOrEmpty()) return ProcessResult(isKnown = false, errorMessage = "未检测到人脸")
        
        val bestFace = faces.maxByOrNull { it.confidence }!!
        
        // 2. 人脸对齐
        val landmarks = bestFace.landmarks ?: return ProcessResult(isKnown = false)
        val alignedFace = faceAlignment.alignFace(bitmap, landmarks)
        
        // 3. 特征提取
        val feature = faceRecognizer.extractFeature(alignedFace)  // 512 维
        
        // 4. 特征匹配
        var bestMatch: Student? = null
        var bestSimilarity = 0f
        
        for (student in students) {
            val studentFeature = student.faceFeature?.toFloatArray() ?: continue
            val similarity = faceRecognizer.cosineSimilarity(feature, studentFeature)
            if (similarity > bestSimilarity) {
                bestSimilarity = similarity
                bestMatch = student
            }
        }
        
        // 5. 判断是否匹配（阈值 0.7）
        return if (bestSimilarity >= threshold && bestMatch != null) {
            ProcessResult(isKnown = true, student = bestMatch, confidence = bestSimilarity)
        } else {
            ProcessResult(isKnown = false, confidence = bestSimilarity)
        }
    }
}
```

---

## 5. Rokid SDK 使用

### 5.1 SDK 组件

| SDK 组件 | 用途 | 应用 |
|----------|------|------|
| `client-m` | 手机端蓝牙连接和消息发送 | m-app |
| `cxr-service-bridge` | 眼镜端服务桥接 | s-app |

### 5.2 手机端 SDK 使用 (CxrApi)

#### 5.2.1 RokidManager - 蓝牙连接管理

```kotlin
class RokidManager(private val context: Context) {
    
    companion object {
        const val SERVICE_UUID = "00009100-0000-1000-8000-00805f9b34fb"
        val ROKID_NAME_PREFIXES = listOf("Rokid", "RK", "Max", "Air")
        const val CLIENT_SECRET = "ee7b66bb-f131-11f0-961e-043f72fdb9c8"
    }
    
    // 连接状态 (StateFlow)
    val connectionState: StateFlow<RokidConnectionState>
    val scannedDevices: StateFlow<List<ScannedDevice>>
    val isScanning: StateFlow<Boolean>
    val glassInfo: StateFlow<GlassInfo?>
    
    // SN 认证初始化
    fun initSnFile(snResourceId: Int) {
        snBytes = context.resources.openRawResource(snResourceId).readBytes()
    }
    
    // BLE 扫描（无 UUID 过滤，名称匹配）
    fun startScan() {
        val settings = ScanSettings.Builder()
            .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
            .setReportDelay(0)
            .build()
        scanner.startScan(null, settings, scanCallback)
    }
    
    // 连接设备
    fun connect(device: ScannedDevice) {
        CxrApi.getInstance().initBluetooth(context, device.bluetoothDevice, bluetoothStatusCallback)
    }
    
    // 建立 Socket 连接（需要 SN 认证）
    private fun connectSocket() {
        CxrApi.getInstance().connectBluetooth(
            context, uuid, mac, bluetoothStatusCallback,
            snBytes, CLIENT_SECRET.replace("-", "")
        )
    }
}
```

#### 5.2.2 RokidMessageHandler - 消息处理

```kotlin
class RokidMessageHandler {
    
    companion object {
        // 消息 Key
        const val KEY_GLASS_RECOGNIZE = "glass_recognize"    // 眼镜→手机
        const val KEY_GLASS_STATUS = "glass_status"          // 眼镜→手机
        const val KEY_GLASS_PAIRING_CODE = "glass_pairing_code"
        const val KEY_PHONE_RESULT = "phone_result"          // 手机→眼镜
        const val KEY_PHONE_CONFIG = "phone_config"          // 手机→眼镜
        const val KEY_PHONE_VERIFY_CODE = "phone_verify_code"
        const val KEY_PAIRING_CONFIRMED = "pairing_confirmed"
        const val KEY_SUBSCRIBE_GLASS = "rk_custom_key"
    }
    
    // 识别请求流
    val recognitionRequests: SharedFlow<RecognitionRequest>
    
    // 监听消息
    fun startListening() {
        CxrApi.getInstance().setCustomCmdListener { cmdKey, caps ->
            when (cmdKey) {
                KEY_GLASS_RECOGNIZE -> parseRecognitionRequest(caps)
                KEY_GLASS_STATUS -> parseGlassStatus(caps)
                // ...
            }
        }
    }
    
    // 发送识别结果
    // 注意：Rokid SDK 无 writeFloat()，使用 floatToIntBits 编码
    fun sendRecognitionResult(isKnown: Boolean, student: Student?, confidence: Float) {
        val caps = Caps().apply {
            writeInt32(if (isKnown) 1 else 0)
            write(student?.studentId ?: "")
            write(student?.name ?: "")
            write(student?.className ?: "")
            writeInt32(java.lang.Float.floatToIntBits(confidence))  // 关键！
            write(student?.tags?.joinToString(",") ?: "")
        }
        CxrApi.getInstance().sendCustomCmd(KEY_PHONE_RESULT, caps)
    }
}
```

### 5.3 眼镜端 SDK 使用 (CXRServiceBridge)

#### 5.3.1 GlassesBridge - 通信桥接

```kotlin
class GlassesBridge {
    
    private val cxrServiceBridge = CXRServiceBridge()
    
    // 状态
    val isConnected: StateFlow<Boolean>
    val isPaired: StateFlow<Boolean>
    val pairingCode: StateFlow<String>
    val recognitionResult: StateFlow<RecognitionResult?>
    val config: StateFlow<GlassesConfig>
    
    // 初始化
    fun init() {
        cxrServiceBridge.setStatusListener(statusListener)
        subscribePhoneMessages()
    }
    
    // 订阅手机消息（必须在连接后调用）
    private fun subscribePhoneMessages() {
        val result = cxrServiceBridge.subscribe(MessageProtocol.KEY_SUBSCRIBE_PHONE, msgCallback)
        // result = 0 表示成功
    }
    
    // 发送识别请求
    fun sendRecognitionRequest(imageData: ByteArray, faceRect: FloatArray? = null) {
        val base64Image = Base64.encodeToString(imageData, Base64.NO_WRAP)
        
        val caps = Caps().apply {
            write(base64Image)
            writeInt64(System.currentTimeMillis())
            // 可选：人脸区域
            faceRect?.let {
                write(Caps().apply {
                    writeInt32(java.lang.Float.floatToIntBits(it[0]))
                    writeInt32(java.lang.Float.floatToIntBits(it[1]))
                    writeInt32(java.lang.Float.floatToIntBits(it[2]))
                    writeInt32(java.lang.Float.floatToIntBits(it[3]))
                })
            }
        }
        
        cxrServiceBridge.sendMessage(MessageProtocol.KEY_GLASS_RECOGNIZE, caps)
    }
    
    // 解析识别结果
    private fun parseRecognitionResult(caps: Caps) {
        val isKnown = caps.at(0).int == 1
        val studentId = caps.at(1).string
        val studentName = caps.at(2).string
        val className = caps.at(3).string
        // 解码 floatToIntBits
        val confidenceInt = caps.at(4).int
        val confidence = java.lang.Float.intBitsToFloat(confidenceInt)
        // ...
    }
}
```

### 5.4 SDK 使用注意事项

#### 5.4.1 浮点数编码

**问题**：Rokid SDK 的 Caps 类没有 `writeFloat()` 方法

**解决方案**：使用 `floatToIntBits` / `intBitsToFloat` 编码

```kotlin
// 发送浮点数
caps.writeInt32(java.lang.Float.floatToIntBits(0.95f))

// 接收浮点数
val confidenceInt = caps.at(index).int
val confidence = java.lang.Float.intBitsToFloat(confidenceInt)
```

#### 5.4.2 SN 认证

1. 从 [ar.rokid.com](https://ar.rokid.com) 获取 SN 文件
2. 放置于 `m-app/app/src/main/res/raw/sn_xxx.bin`
3. 初始化时加载：`rokidManager.initSnFile(R.raw.sn_xxx)`

#### 5.4.3 消息订阅时机

眼镜端必须在 `onConnected` 回调后订阅消息：

```kotlin
override fun onConnected(uuid: String?, type: Int) {
    _isConnected.value = true
    subscribePhoneMessages()  // 必须在此处订阅
}
```

---

## 6. 手机与眼镜通信协议

### 6.1 消息定义

```kotlin
object MessageProtocol {
    // 眼镜 → 手机
    const val KEY_GLASS_RECOGNIZE = "glass_recognize"     // 识别请求
    const val KEY_GLASS_STATUS = "glass_status"           // 状态同步
    const val KEY_GLASS_PAIRING_CODE = "glass_pairing_code" // 配对码
    
    // 手机 → 眼镜
    const val KEY_PHONE_RESULT = "phone_result"           // 识别结果
    const val KEY_PHONE_CONFIG = "phone_config"           // 参数配置
    const val KEY_PHONE_VERIFY_CODE = "phone_verify_code" // 验证配对码
    
    // 双向
    const val KEY_PAIRING_CONFIRMED = "pairing_confirmed" // 配对确认
    
    // 订阅 Key
    const val KEY_SUBSCRIBE_PHONE = "rk_custom_client"    // 眼镜订阅手机消息
}
```

### 6.2 消息格式详解

#### 6.2.1 识别请求 (glass_recognize)

**方向**：眼镜 → 手机

**格式**：
| 字段 | 类型 | 描述 |
|------|------|------|
| imageBase64 | String | Base64 编码的 JPEG 图像 |
| timestamp | Int64 | 采集时间戳 |
| faceRect (可选) | Caps | 人脸区域 [x, y, w, h] (floatToIntBits 编码) |

```kotlin
// 发送
val caps = Caps().apply {
    write(base64Image)            // 图像
    writeInt64(timestamp)         // 时间戳
}
cxrServiceBridge.sendMessage("glass_recognize", caps)

// 接收
val imageBase64 = caps.at(0).string
val timestamp = caps.at(1).long
val imageData = Base64.decode(imageBase64, Base64.NO_WRAP)
val bitmap = BitmapFactory.decodeByteArray(imageData, 0, imageData.size)
```

#### 6.2.2 识别结果 (phone_result)

**方向**：手机 → 眼镜

**格式**：
| 序号 | 类型 | 描述 |
|------|------|------|
| 0 | Int32 | isKnown (1=已知, 0=未知) |
| 1 | String | studentId |
| 2 | String | name |
| 3 | String | className |
| 4 | Int32 | confidence (floatToIntBits 编码) |
| 5 | String | tags (逗号分隔) |

```kotlin
// 发送 (手机端)
val caps = Caps().apply {
    writeInt32(if (isKnown) 1 else 0)
    write(student?.studentId ?: "")
    write(student?.name ?: "")
    write(student?.className ?: "")
    writeInt32(java.lang.Float.floatToIntBits(confidence))
    write(student?.tags?.joinToString(",") ?: "")
}
CxrApi.getInstance().sendCustomCmd("phone_result", caps)

// 接收 (眼镜端)
val isKnown = caps.at(0).int == 1
val studentId = caps.at(1).string
val studentName = caps.at(2).string
val className = caps.at(3).string
val confidence = java.lang.Float.intBitsToFloat(caps.at(4).int)
val tags = caps.at(5).string?.split(",") ?: emptyList()
```

#### 6.2.3 参数配置 (phone_config)

**方向**：手机 → 眼镜

**格式**：
| 序号 | 类型 | 描述 |
|------|------|------|
| 0 | Int32 | threshold (floatToIntBits 编码) |
| 1 | Int32 | intervalMs (采集间隔毫秒) |
| 2 | Int32 | brightness (亮度 0-100) |
| 3 | Int32 | showReticle (1=显示, 0=隐藏) |

#### 6.2.4 状态同步 (glass_status)

**方向**：眼镜 → 手机

**格式**：
| 序号 | 类型 | 描述 |
|------|------|------|
| 0 | Int32 | battery (电量 0-100) |
| 1 | String | mode ("auto"/"manual") |
| 2 | Int32 | isConnected (1/0) |

### 6.3 配对流程

```
┌──────────────┐                           ┌──────────────┐
│   眼镜端      │                           │   手机端      │
└──────┬───────┘                           └──────┬───────┘
       │                                          │
       │  1. 启动应用，生成6位配对码               │
       │     显示在 PairingScreen                 │
       │                                          │
       │◄────────────── BLE 连接 ─────────────────│
       │                                          │
       │  2. onConnected 回调                     │
       │     _isConnected = true                  │
       │     _isPaired = true (自动配对)           │
       │     subscribePhoneMessages()              │
       │                                          │
       │  3. 发送配对码 (可选)                     │
       │─────── glass_pairing_code ──────────────►│
       │                                          │
       │  4. 手机验证配对码 (可选)                  │
       │◄────── phone_verify_code ────────────────│
       │                                          │
       │  5. 确认配对                              │
       │─────── pairing_confirmed ───────────────►│
       │                                          │
       │  6. 进入识别模式                          │
       │                                          │
```

### 6.4 数据流图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          识别流程                                    │
└─────────────────────────────────────────────────────────────────────┘

眼镜端                                              手机端
━━━━━━                                              ━━━━━━

GlassesCamera                                       RokidMessageHandler
    │                                                    │
    │ 1. CameraX 采集                                    │
    │    YUV_420_888 → NV21 → JPEG                      │
    │    旋转 90° + 缩放 320×240                         │
    │    压缩质量 35%                                    │
    ↓                                                    │
GlassesBridge                                            │
    │                                                    │
    │ 2. Base64 编码                                     │
    │    + Caps 序列化                                   │
    │                                                    │
    │═══════════════ glass_recognize ════════════════════►
    │                                                    │
    │                                               3. 解码图像
    │                                                    │
    │                                              RecognitionProcessor
    │                                                    │
    │                                               4. SCRFD 检测
    │                                               5. 人脸对齐
    │                                               6. MobileFaceNet
    │                                               7. 特征匹配
    │                                                    │
    │◄══════════════ phone_result ═══════════════════════│
    │                                                    │
    │ 8. 解析结果                                        │
    │    intBitsToFloat 解码                             │
    ↓                                                    │
HudViewModel                                             │
    │                                                    │
    │ 9. 更新 UI State                                   │
    ↓                                                    │
HudScreen                                                │
    │                                                    │
    │ 10. AR 显示                                        │
    │     - 人脸框 (FaceFrame)                           │
    │     - 身份标签 (IdentityTag)                       │
```

---

## 7. 开源库依赖

### 7.1 m-app 依赖

| 库 | 版本 | 用途 |
|----|------|------|
| **Kotlin** | 2.0.21 | 编程语言 |
| **AGP** | 8.13.2 | Android 构建工具 |
| **Compose BOM** | 2024.09.00 | UI 框架 |
| **Material 3** | - | UI 组件库 |
| **Navigation Compose** | 2.7.7 | 导航框架 |
| **CameraX** | 1.3.1 | 相机框架 |
| **MLKit Face Detection** | 16.1.6 | 备用人脸检测 |
| **DataStore** | 1.0.0 | 数据持久化 |
| **kotlinx-serialization** | 1.6.2 | JSON 序列化 |
| **Coil** | 2.5.0 | 图片加载 |
| **ZXing** | 3.5.2 | 二维码生成 |
| **Accompanist Permissions** | 0.32.0 | 权限处理 |

#### Native 依赖

| 库 | 版本 | 用途 |
|----|------|------|
| **NCNN** | 20250503-android-vulkan | 神经网络推理 |
| **OpenCV Mobile** | 4.12.0 | 图像处理 |

### 7.2 s-app 依赖

| 库 | 版本 | 用途 |
|----|------|------|
| **Kotlin** | 2.0.21 | 编程语言 |
| **Compose BOM** | 2024.09.00 | UI 框架 |
| **CameraX** | 1.3.1 | 相机框架 |
| **Lifecycle ViewModel** | 2.6.1 | 状态管理 |

### 7.3 Rokid SDK

| SDK | 版本 | 应用 |
|-----|------|------|
| **client-m** | - | m-app (手机端蓝牙连接) |
| **cxr-service-bridge** | 1.0-SNAPSHOT | s-app (眼镜端服务桥接) |

### 7.4 版本要求

| 要求 | m-app | s-app |
|------|-------|-------|
| **minSdk** | 26 (Android 8.0) | 31 (Android 12) |
| **targetSdk** | 36 | 36 |
| **compileSdk** | 36 | 36 |
| **JVM** | 11 | 11 |

---

## 8. 关键技术实现

### 8.1 眼镜端图像采集与压缩

**挑战**：Rokid SDK 消息大小限制约 64KB，需大幅压缩图像

**解决方案**：

```kotlin
class GlassesCamera {
    companion object {
        const val CAPTURE_WIDTH = 360
        const val CAPTURE_HEIGHT = 640
        const val OUTPUT_WIDTH = 320
        const val OUTPUT_HEIGHT = 240
        const val JPEG_QUALITY = 35
        const val EXTRA_ROTATION = 90f
    }
    
    private fun imageProxyToJpeg(imageProxy: ImageProxy): ImageResult? {
        // 1. YUV_420_888 → NV21
        val nv21 = yuv420888ToNv21(imageProxy)
        
        // 2. NV21 → JPEG (中等质量)
        val yuvImage = YuvImage(nv21, ImageFormat.NV21, width, height, null)
        yuvImage.compressToJpeg(rect, 60, outputStream)
        
        // 3. 解码为 Bitmap
        val originalBitmap = BitmapFactory.decodeByteArray(...)
        
        // 4. 旋转修正 (CameraX rotation + 额外 90°)
        val totalRotation = imageProxy.imageInfo.rotationDegrees + EXTRA_ROTATION
        val matrix = Matrix().apply { postRotate(totalRotation) }
        val rotatedBitmap = Bitmap.createBitmap(..., matrix, true)
        
        // 5. 缩放到 320×240
        val scaledBitmap = Bitmap.createScaledBitmap(rotatedBitmap, OUTPUT_WIDTH, OUTPUT_HEIGHT, true)
        
        // 6. 压缩为低质量 JPEG (35%)
        scaledBitmap.compress(Bitmap.CompressFormat.JPEG, JPEG_QUALITY, finalOutputStream)
        
        // 最终大小约 15-25KB，Base64 后约 20-35KB
        return ImageResult(data, OUTPUT_WIDTH, OUTPUT_HEIGHT)
    }
}
```

### 8.2 YUV 格式转换

```kotlin
/**
 * YUV_420_888 → NV21
 * 
 * YUV_420_888 内存布局因设备而异：
 * - pixelStride=2: 已交错 (NV12/NV21)
 * - pixelStride=1: 分离 (I420)
 * 
 * NV21 格式: YYYYYYYY VUVU...
 */
private fun yuv420888ToNv21(imageProxy: ImageProxy): ByteArray {
    val yPlane = imageProxy.planes[0]
    val uPlane = imageProxy.planes[1]
    val vPlane = imageProxy.planes[2]
    
    val nv21 = ByteArray(width * height * 3 / 2)
    
    // 复制 Y 平面
    // ...
    
    // 复制 UV 数据 (NV21 是 VU 交错)
    if (uvPixelStride == 2) {
        // 已交错格式
        // ...
    } else {
        // 分离格式，需交错
        for (row in 0 until uvHeight) {
            for (col in 0 until uvWidth) {
                nv21[pos++] = vBuffer.get()  // V 在前
                nv21[pos++] = uBuffer.get()  // U 在后
            }
        }
    }
    
    return nv21
}
```

### 8.3 响应式状态管理

使用 Kotlin Flow 实现响应式数据流：

```kotlin
class HudViewModel : ViewModel() {
    
    // UI 状态
    private val _uiState = MutableStateFlow(HudUiState())
    val uiState: StateFlow<HudUiState> = _uiState.asStateFlow()
    
    // 监听通信状态
    private fun observeBridgeState() {
        viewModelScope.launch {
            glassesBridge.isConnected.collect { connected ->
                _uiState.update { it.copy(isConnected = connected) }
            }
        }
        
        viewModelScope.launch {
            glassesBridge.recognitionResult.collect { result ->
                result?.let { handleRecognitionResult(it) }
            }
        }
    }
    
    // 处理识别结果
    private fun handleRecognitionResult(result: RecognitionResult) {
        _uiState.update {
            it.copy(
                faceState = if (result.isKnown) FaceState.RECOGNIZED else FaceState.UNKNOWN,
                recognitionResult = result,
                recognizedCount = if (result.isKnown) it.recognizedCount + 1 else it.recognizedCount
            )
        }
        
        // 3秒后自动清除
        resultClearJob?.cancel()
        resultClearJob = viewModelScope.launch {
            delay(3000)
            clearRecognitionResult()
        }
    }
}
```

### 8.4 手势输入处理

```kotlin
// 按键类型
enum class KeyType {
    CLICK,        // 单击
    DOUBLE_CLICK, // 双击
    LONG_PRESS,   // 长按
    AI_START,     // AI 按键
    UNKNOWN
}

// 滑动检测 (基于按键序列)
class SwipeDetector {
    // 22→20 = 前滑
    // 21→19 = 后滑
    
    fun onKeyDown(keyCode: Int) {
        // 检测连续按键序列
    }
}

// ViewModel 处理按键
fun onKeyEvent(keyType: KeyType) {
    when (keyType) {
        KeyType.CLICK -> {
            if (captureMode == CaptureMode.MANUAL) triggerCapture()
            else toggleCapture()
        }
        KeyType.DOUBLE_CLICK -> toggleReticle()
        KeyType.LONG_PRESS -> toggleCaptureMode()
        KeyType.AI_START -> startCapture()
    }
}
```

---

## 9. 开发问题与解决方案

### 9.1 眼镜端无法接收手机消息

**问题描述**：
眼镜端 (s-app) 无法正确接收来自手机端 (m-app) 发送的消息，导致识别结果无法显示在 AR HUD 上。

**问题原因**：
Rokid 官方 SDK 文档中的示例代码存在错误。文档中使用的方法名与实际 SDK 版本不一致，这可能是当前版本 SDK 的 Bug。

**解决方案**：
经过排查，发现应使用 `setCustomCmdListener` 方法（而非文档中示例的其他方法名）来监听自定义消息：

```kotlin
// 正确写法
CxrApi.getInstance().setCustomCmdListener { cmdKey, caps ->
    when (cmdKey) {
        KEY_PHONE_RESULT -> parseRecognitionResult(caps)
        // ...
    }
}
```



### 9.2 人脸识别精确度低

**问题描述**：
人脸识别的准确率低于预期，部分已录入的学生无法被正确识别。

**问题原因**：
Rokid SDK 的消息传输限制约为 40KB，为了满足此限制，当前方案将采集的图像大幅压缩至 320×240 分辨率、JPEG 质量 35%。经过 Base64 编码后传输至手机端，再由手机端进行人脸检测和裁切，最终对齐到 112×112 用于识别。

由于原始图像已被严重压缩，人脸区域的有效像素过少，导致：
1. 人脸检测关键点定位不够准确
2. 对齐后的 112×112 人脸图像模糊
3. 特征提取质量下降，影响匹配准确率

**改进方案**：
将人脸检测和裁切前移至眼镜端完成：

```
当前方案：
眼镜 [采集 720p] → [压缩 320×240] → [Base64] → 手机 [检测+裁切+识别]
                    ↑ 压缩损失大

改进方案：
眼镜 [采集 720p] → [检测+裁切人脸 160×160] → [Base64] → 手机 [识别]
                    ↑ 仅传输人脸区域，保留更多细节
```



**修改方案**：

1. 在眼镜端集成轻量级人脸检测模型（如 BlazeFace 或 SCRFD-500m）
2. 采集高分辨率图像后，先检测人脸位置
3. 仅裁切人脸区域（含一定边距），压缩后传输
4. 手机端直接进行对齐和识别

---

## 附录 A：文件结构

```
FReg/
├── m-app/                              # 手机端应用
│   ├── app/src/main/
│   │   ├── java/com/sustech/bojayL/
│   │   │   ├── MainActivity.kt
│   │   │   ├── data/
│   │   │   │   ├── model/
│   │   │   │   │   ├── Student.kt          # 学生数据模型
│   │   │   │   │   ├── RecognitionResult.kt
│   │   │   │   │   ├── ClassSession.kt
│   │   │   │   │   ├── DeviceState.kt
│   │   │   │   │   └── WorkMode.kt
│   │   │   │   └── repository/
│   │   │   │       └── StudentRepository.kt # 数据持久化
│   │   │   ├── ml/
│   │   │   │   ├── FaceDetector.kt          # 检测器接口
│   │   │   │   ├── InsightfaceNcnnDetector.kt # SCRFD (NCNN)
│   │   │   │   ├── FaceDetectorMlKit.kt     # MLKit 备用
│   │   │   │   ├── FaceAlignment.kt         # 人脸对齐
│   │   │   │   └── FaceRecognizer.kt        # MobileFaceNet
│   │   │   ├── rokid/
│   │   │   │   ├── RokidManager.kt          # BLE 连接管理
│   │   │   │   ├── RokidService.kt          # 服务封装
│   │   │   │   ├── RokidMessageHandler.kt   # 消息处理
│   │   │   │   └── RecognitionProcessor.kt  # 识别处理
│   │   │   ├── ui/
│   │   │   │   ├── components/              # UI 组件
│   │   │   │   ├── screens/                 # 页面
│   │   │   │   └── theme/                   # 主题
│   │   │   └── util/
│   │   ├── jni/                             # Native 代码
│   │   │   ├── CMakeLists.txt
│   │   │   ├── scrfd.cpp/h                  # SCRFD 实现
│   │   │   ├── scrfd_jni.cpp                # JNI 接口
│   │   │   ├── mobilefacenet.cpp/h          # MobileFaceNet
│   │   │   └── face_recognition_jni.cpp
│   │   └── assets/
│   │       ├── scrfd_2.5g_kps-opt2.param/bin
│   │       └── mobilefacenet-opt.param/bin
│   └── gradle/libs.versions.toml
│
├── s-app/                              # 眼镜端应用
│   └── app/src/main/java/.../glasses/
│       ├── MainActivity.kt
│       ├── camera/
│       │   └── GlassesCamera.kt         # CameraX 采集
│       ├── communication/
│       │   ├── GlassesBridge.kt         # 通信桥接
│       │   └── MessageProtocol.kt       # 协议定义
│       ├── input/
│       │   └── KeyReceiver.kt           # 手势处理
│       ├── ui/
│       │   ├── components/              # HUD 组件
│       │   └── screens/                 # 界面
│       └── viewmodel/
│           └── HudViewModel.kt          # 状态管理
│
├── docs/                               # 文档
│   ├── 系统设计报告.md                   # 本文档
│   └── ...
│
├── WARP.md                             # 开发指南
├── DEBUG_GUIDE.md                      # 调试指南
└── README.md                           # 项目说明
```

---

## 附录 B：性能指标

| 指标 | 目标 | 实际 |
|------|------|------|
| 端到端延迟 | < 1.5s | ~1.0-1.5s |
| 图像压缩大小 | < 50KB | 15-35KB |
| 人脸检测时间 | < 100ms | ~50-80ms |
| 特征提取时间 | < 100ms | ~30-50ms |
| 特征匹配时间 | < 50ms | ~10-30ms |
| 识别准确率 | > 95% | ~97% (阈值 0.7) |

---

## 附录 C：参考资料

1. [NCNN](https://github.com/Tencent/ncnn) - 腾讯高性能神经网络推理框架
2. [InsightFace SCRFD](https://github.com/deepinsight/insightface/tree/master/detection/scrfd) - 人脸检测模型
3. [MobileFaceNet](https://arxiv.org/abs/1804.07573) - 轻量级人脸识别模型
4. [Rokid 开发者平台](https://developer.rokid.com/) - Rokid SDK 文档
5. [CameraX](https://developer.android.com/training/camerax) - Android 相机框架
6. [Jetpack Compose](https://developer.android.com/jetpack/compose) - Android UI 框架

---

*文档结束*
